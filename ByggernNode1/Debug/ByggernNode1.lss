
ByggernNode1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001e  00800100  00000638  000006ac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000638  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .stab         00000cf0  00000000  00000000  000006cc  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000272  00000000  00000000  000013bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .comment      0000002f  00000000  00000000  0000162e  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000240  00000000  00000000  0000165d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001db0  00000000  00000000  0000189d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ff9  00000000  00000000  0000364d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000014f6  00000000  00000000  00004646  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000045c  00000000  00000000  00005b3c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000007c5  00000000  00000000  00005f98  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000016ff  00000000  00000000  0000675d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000188  00000000  00000000  00007e5c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:

uint8_t ADC_read(uint8_t channel) {
	//Address for the ADC
	volatile char *adc = (char *) 0x1400;
	
	if(channel > 3) {return 0;}
   0:	0c 94 b4 01 	jmp	0x368	; 0x368 <__ctors_end>
	
	//Choose channel in ADC
	*adc = 0x04 | channel;
   4:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
   8:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
	
	//Wait for the data to be read
	while(test_bit(PINE, PINE0));
   c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
	
	return *adc;
  10:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>

uint8_t ADC_read(uint8_t channel) {
	//Address for the ADC
	volatile char *adc = (char *) 0x1400;
	
	if(channel > 3) {return 0;}
  14:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
	x = ADC_read(0);
	//Read position y from channel 1
	y = ADC_read(1);
	
	//Calculate position x percentage
	if(x > mid_x) {
  18:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
		position.x = 100 * (x - mid_x) / (0xFF - mid_x);
  1c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  20:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  24:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  28:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  2c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  30:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  34:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  38:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  3c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  40:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
	} else if (x < mid_x) {
  44:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
		position.x = 100 * (x - mid_x) / (mid_x - 0);
  48:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  4c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  50:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  54:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  58:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  5c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  60:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  64:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  68:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
	} else {
		position.x = 0;
	}
	
	//Calculate position y percentage
	if(y > mid_y) {
  6c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>

00000070 <font>:
	...
		position.y = 100 * (y - mid_y) / (0xFF - mid_y);
  78:	00 06 5f 5f 06 00 00 00 00 07 07 00 07 07 00 00     ..__............
  88:	14 7f 7f 14 7f 7f 14 00 24 2e 6b 6b 3a 12 00 00     ........$.kk:...
  98:	46 66 30 18 0c 66 62 00 30 7a 4f 5d 37 7a 48 00     Ff0..fb.0zO]7zH.
	} else if (y < mid_y) {
		position.y = 100 * (y - mid_y) / (mid_y - 0);
  a8:	04 07 03 00 00 00 00 00 00 1c 3e 63 41 00 00 00     ..........>cA...
  b8:	00 41 63 3e 1c 00 00 00 08 2a 3e 1c 1c 3e 2a 08     .Ac>.....*>..>*.
	} else {
		position.y = 0;
	}
	
	return position;
}
  c8:	08 08 3e 3e 08 08 00 00 00 a0 e0 60 00 00 00 00     ..>>.......`....
			printf("SRAM error (read phase): ext_ram[%d] = %02X (should be %02X)\r\n", i, ext_ram[i], testvalue);
			rerrors++;
		}
	}

	printf("SRAM test completed with %d errors in write phase and %d errors in read phase\r\n", werrors, rerrors);
  d8:	08 08 08 08 08 08 00 00 00 00 60 60 00 00 00 00     ..........``....
  e8:	60 30 18 0c 06 03 01 00 3e 7f 59 4d 7f 3e 00 00     `0......>.YM.>..
  f8:	42 42 7f 7f 40 40 00 00 62 73 59 49 6f 66 00 00     BB..@@..bsYIof..
 108:	22 63 49 49 7f 36 00 00 18 1c 16 13 7f 7f 10 00     "cII.6..........
 118:	27 67 45 45 7d 39 00 00 3c 7e 4b 49 79 30 00 00     'gEE}9..<~KIy0..
 128:	03 63 71 19 0f 07 00 00 36 7f 49 49 7f 36 00 00     .cq.....6.II.6..
 138:	06 4f 49 69 3f 1e 00 00 00 00 6c 6c 00 00 00 00     .OIi?.....ll....
 148:	00 a0 ec 6c 00 00 00 00 08 1c 36 63 41 00 00 00     ...l......6cA...
 158:	14 14 14 14 14 14 00 00 00 41 63 36 1c 08 00 00     .........Ac6....
 168:	02 03 51 59 0f 06 00 00 3e 7f 41 5d 5d 1f 1e 00     ..QY....>.A]]...
 178:	7c 7e 13 13 7e 7c 00 00 41 7f 7f 49 49 7f 36 00     |~..~|..A..II.6.
 188:	1c 3e 63 41 41 63 22 00 41 7f 7f 41 63 7f 1c 00     .>cAAc".A..Ac...
 198:	41 7f 7f 49 5d 41 63 00 41 7f 7f 49 1d 01 03 00     A..I]Ac.A..I....
 1a8:	1c 3e 63 41 51 73 72 00 7f 7f 08 08 7f 7f 00 00     .>cAQsr.........
 1b8:	00 41 7f 7f 41 00 00 00 30 70 40 41 7f 3f 01 00     .A..A...0p@A.?..
 1c8:	41 7f 7f 08 1c 77 63 00 41 7f 7f 41 40 60 70 00     A....wc.A..A@`p.
 1d8:	7f 7f 06 0c 06 7f 7f 00 7f 7f 06 0c 18 7f 7f 00     ................
 1e8:	1c 3e 63 41 63 3e 1c 00 41 7f 7f 49 09 0f 06 00     .>cAc>..A..I....
 1f8:	1e 3f 21 71 7f 5e 00 00 41 7f 7f 19 39 6f 46 00     .?!q.^..A...9oF.
 208:	26 67 4d 59 7b 32 00 00 03 41 7f 7f 41 03 00 00     &gMY{2...A..A...
 218:	7f 7f 40 40 7f 7f 00 00 1f 3f 60 60 3f 1f 00 00     ..@@.....?``?...
 228:	7f 7f 30 18 30 7f 7f 00 63 77 1c 08 1c 77 63 00     ..0.0...cw...wc.
 238:	07 4f 78 78 4f 07 00 00 67 73 59 4d 47 63 71 00     .OxxO...gsYMGcq.
 248:	00 7f 7f 41 41 00 00 00 01 03 06 0c 18 30 60 00     ...AA........0`.
 258:	00 41 41 7f 7f 00 00 00 08 0c 06 03 06 0c 08 00     .AA.............
 268:	80 80 80 80 80 80 80 80 00 00 03 07 04 00 00 00     ................
 278:	20 74 54 54 3c 78 40 00 41 3f 7f 44 44 7c 38 00      tTT<x@.A?.DD|8.
 288:	38 7c 44 44 6c 28 00 00 30 78 48 49 3f 7f 40 00     8|DDl(..0xHI?.@.
 298:	38 7c 54 54 5c 18 00 00 48 7e 7f 49 03 02 00 00     8|TT\...H~.I....
 2a8:	98 bc a4 a4 f8 7c 04 00 41 7f 7f 08 04 7c 78 00     .....|..A....|x.
 2b8:	00 44 7d 7d 40 00 00 00 40 c4 84 fd 7d 00 00 00     .D}}@...@...}...
 2c8:	41 7f 7f 10 38 6c 44 00 00 41 7f 7f 40 00 00 00     A...8lD..A..@...
 2d8:	7c 7c 0c 18 0c 7c 78 00 7c 7c 04 04 7c 78 00 00     ||...|x.||..|x..
 2e8:	38 7c 44 44 7c 38 00 00 84 fc f8 a4 24 3c 18 00     8|DD|8......$<..
 2f8:	18 3c 24 a4 f8 fc 84 00 44 7c 78 44 1c 18 00 00     .<$.....D|xD....
 308:	48 5c 54 54 74 24 00 00 00 04 3e 7f 44 24 00 00     H\TTt$....>.D$..
 318:	3c 7c 40 40 3c 7c 40 00 1c 3c 60 60 3c 1c 00 00     <|@@<|@..<``<...
 328:	3c 7c 60 30 60 7c 3c 00 44 6c 38 10 38 6c 44 00     <|`0`|<.Dl8.8lD.
 338:	9c bc a0 a0 fc 7c 00 00 4c 64 74 5c 4c 64 00 00     .....|..Ldt\Ld..
 348:	08 08 3e 77 41 41 00 00 00 00 00 77 77 00 00 00     ..>wAA.....ww...
 358:	41 41 77 3e 08 08 00 00 02 03 01 03 02 03 01 00     AAw>............

00000368 <__ctors_end>:
 368:	11 24       	eor	r1, r1
 36a:	1f be       	out	0x3f, r1	; 63
 36c:	cf ef       	ldi	r28, 0xFF	; 255
 36e:	d4 e0       	ldi	r29, 0x04	; 4
 370:	de bf       	out	0x3e, r29	; 62
 372:	cd bf       	out	0x3d, r28	; 61

00000374 <__do_copy_data>:
 374:	11 e0       	ldi	r17, 0x01	; 1
 376:	a0 e0       	ldi	r26, 0x00	; 0
 378:	b1 e0       	ldi	r27, 0x01	; 1
 37a:	e8 e3       	ldi	r30, 0x38	; 56
 37c:	f6 e0       	ldi	r31, 0x06	; 6
 37e:	02 c0       	rjmp	.+4      	; 0x384 <__do_copy_data+0x10>
 380:	05 90       	lpm	r0, Z+
 382:	0d 92       	st	X+, r0
 384:	ae 31       	cpi	r26, 0x1E	; 30
 386:	b1 07       	cpc	r27, r17
 388:	d9 f7       	brne	.-10     	; 0x380 <__do_copy_data+0xc>

0000038a <__do_clear_bss>:
 38a:	21 e0       	ldi	r18, 0x01	; 1
 38c:	ae e1       	ldi	r26, 0x1E	; 30
 38e:	b1 e0       	ldi	r27, 0x01	; 1
 390:	01 c0       	rjmp	.+2      	; 0x394 <.do_clear_bss_start>

00000392 <.do_clear_bss_loop>:
 392:	1d 92       	st	X+, r1

00000394 <.do_clear_bss_start>:
 394:	ae 31       	cpi	r26, 0x1E	; 30
 396:	b2 07       	cpc	r27, r18
 398:	e1 f7       	brne	.-8      	; 0x392 <.do_clear_bss_loop>
 39a:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <main>
 39e:	0c 94 1a 03 	jmp	0x634	; 0x634 <_exit>

000003a2 <__bad_interrupt>:
 3a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000003a6 <main>:
 3a6:	0e 94 31 02 	call	0x462	; 0x462 <OLED_init>
 3aa:	80 e0       	ldi	r24, 0x00	; 0
 3ac:	90 e0       	ldi	r25, 0x00	; 0
 3ae:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <OLED_goto_line>
 3b2:	8a e0       	ldi	r24, 0x0A	; 10
 3b4:	91 e0       	ldi	r25, 0x01	; 1
 3b6:	0e 94 05 03 	call	0x60a	; 0x60a <OLED_printf>

	/*TEST OLED*/
	OLED_init();
	OLED_goto_line(0);
	OLED_printf("0123456789012345");
	OLED_pos(5,8);
 3ba:	68 e0       	ldi	r22, 0x08	; 8
 3bc:	70 e0       	ldi	r23, 0x00	; 0
 3be:	85 e0       	ldi	r24, 0x05	; 5
 3c0:	90 e0       	ldi	r25, 0x00	; 0
 3c2:	0e 94 db 02 	call	0x5b6	; 0x5b6 <OLED_pos>
	OLED_printf("h2");
 3c6:	8b e1       	ldi	r24, 0x1B	; 27
 3c8:	91 e0       	ldi	r25, 0x01	; 1
 3ca:	0e 94 05 03 	call	0x60a	; 0x60a <OLED_printf>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 3ce:	21 e3       	ldi	r18, 0x31	; 49
 3d0:	80 e0       	ldi	r24, 0x00	; 0
 3d2:	9f e0       	ldi	r25, 0x0F	; 15
 3d4:	21 50       	subi	r18, 0x01	; 1
 3d6:	80 40       	sbci	r24, 0x00	; 0
 3d8:	90 40       	sbci	r25, 0x00	; 0
 3da:	e1 f7       	brne	.-8      	; 0x3d4 <main+0x2e>
 3dc:	00 c0       	rjmp	.+0      	; 0x3de <main+0x38>
 3de:	00 00       	nop
 3e0:	f6 cf       	rjmp	.-20     	; 0x3ce <main+0x28>

000003e2 <OLED_goto_line>:
	return 0;
}

int OLED_goto_line(int line) {
	//Set lower column address
	*oled_cm = 0x00;
 3e2:	e0 91 08 01 	lds	r30, 0x0108
 3e6:	f0 91 09 01 	lds	r31, 0x0109
 3ea:	10 82       	st	Z, r1
	//Set higher column address
	*oled_cm = 0x10;
 3ec:	e0 91 08 01 	lds	r30, 0x0108
 3f0:	f0 91 09 01 	lds	r31, 0x0109
 3f4:	20 e1       	ldi	r18, 0x10	; 16
 3f6:	20 83       	st	Z, r18
	//Set page address
	if (line < 8) {
 3f8:	88 30       	cpi	r24, 0x08	; 8
 3fa:	91 05       	cpc	r25, r1
 3fc:	54 f4       	brge	.+20     	; 0x412 <OLED_goto_line+0x30>
		*oled_cm = 0xB0 | line;
 3fe:	e0 91 08 01 	lds	r30, 0x0108
 402:	f0 91 09 01 	lds	r31, 0x0109
 406:	80 6b       	ori	r24, 0xB0	; 176
 408:	9f 6f       	ori	r25, 0xFF	; 255
 40a:	80 83       	st	Z, r24
	} else {
		return 1;
	}
	
	return 0;
 40c:	20 e0       	ldi	r18, 0x00	; 0
 40e:	30 e0       	ldi	r19, 0x00	; 0
 410:	02 c0       	rjmp	.+4      	; 0x416 <OLED_goto_line+0x34>
	*oled_cm = 0x10;
	//Set page address
	if (line < 8) {
		*oled_cm = 0xB0 | line;
	} else {
		return 1;
 412:	21 e0       	ldi	r18, 0x01	; 1
 414:	30 e0       	ldi	r19, 0x00	; 0
	}
	
	return 0;
}
 416:	82 2f       	mov	r24, r18
 418:	93 2f       	mov	r25, r19
 41a:	08 95       	ret

0000041c <OLED_clear_line>:

int OLED_clear_line(int line) {
	//Set page address
	int r = OLED_goto_line(line);
 41c:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <OLED_goto_line>
	
	//Clear the page
	if (r == 0) {
 420:	89 2b       	or	r24, r25
 422:	a1 f0       	breq	.+40     	; 0x44c <OLED_clear_line+0x30>
			for(int i = 0; i < 8; i++) {
				*oled_dt = pgm_read_byte(&font[0][i]);
			}
		}
	} else {
		return 1;
 424:	21 e0       	ldi	r18, 0x01	; 1
 426:	30 e0       	ldi	r19, 0x00	; 0
 428:	19 c0       	rjmp	.+50     	; 0x45c <OLED_clear_line+0x40>
	
	//Clear the page
	if (r == 0) {
		for (int j = 0; j < 16; j++) {
			for(int i = 0; i < 8; i++) {
				*oled_dt = pgm_read_byte(&font[0][i]);
 42a:	a0 91 06 01 	lds	r26, 0x0106
 42e:	b0 91 07 01 	lds	r27, 0x0107
 432:	fc 01       	movw	r30, r24
 434:	e0 59       	subi	r30, 0x90	; 144
 436:	ff 4f       	sbci	r31, 0xFF	; 255
 438:	e4 91       	lpm	r30, Z
 43a:	ec 93       	st	X, r30
	int r = OLED_goto_line(line);
	
	//Clear the page
	if (r == 0) {
		for (int j = 0; j < 16; j++) {
			for(int i = 0; i < 8; i++) {
 43c:	01 96       	adiw	r24, 0x01	; 1
 43e:	88 30       	cpi	r24, 0x08	; 8
 440:	91 05       	cpc	r25, r1
 442:	99 f7       	brne	.-26     	; 0x42a <OLED_clear_line+0xe>
 444:	21 50       	subi	r18, 0x01	; 1
 446:	31 09       	sbc	r19, r1
	//Set page address
	int r = OLED_goto_line(line);
	
	//Clear the page
	if (r == 0) {
		for (int j = 0; j < 16; j++) {
 448:	29 f4       	brne	.+10     	; 0x454 <OLED_clear_line+0x38>
 44a:	06 c0       	rjmp	.+12     	; 0x458 <OLED_clear_line+0x3c>
int OLED_clear_line(int line) {
	//Set page address
	int r = OLED_goto_line(line);
	
	//Clear the page
	if (r == 0) {
 44c:	20 e1       	ldi	r18, 0x10	; 16
 44e:	30 e0       	ldi	r19, 0x00	; 0
	}
	
	return 0;
}

int OLED_clear_line(int line) {
 450:	40 e0       	ldi	r20, 0x00	; 0
 452:	50 e0       	ldi	r21, 0x00	; 0
 454:	ca 01       	movw	r24, r20
 456:	e9 cf       	rjmp	.-46     	; 0x42a <OLED_clear_line+0xe>
		}
	} else {
		return 1;
	}
	
	return 0;
 458:	20 e0       	ldi	r18, 0x00	; 0
 45a:	30 e0       	ldi	r19, 0x00	; 0
}
 45c:	82 2f       	mov	r24, r18
 45e:	93 2f       	mov	r25, r19
 460:	08 95       	ret

00000462 <OLED_init>:
//Address for the OLED commands
volatile char *oled_cm = (char *) 0x1000;
//Address for the OLED data
volatile char *oled_dt = (char *) 0x1200;

int OLED_init(void) {
 462:	cf 93       	push	r28
 464:	df 93       	push	r29
	//Enable the external memory interface/4 bits address
	MCUCR  |= (1<<SRE);
 466:	85 b7       	in	r24, 0x35	; 53
 468:	80 68       	ori	r24, 0x80	; 128
 46a:	85 bf       	out	0x35, r24	; 53
	SFIOR  |= (1<<XMM2);
 46c:	80 b7       	in	r24, 0x30	; 48
 46e:	80 62       	ori	r24, 0x20	; 32
 470:	80 bf       	out	0x30, r24	; 48

	//Setup the OLED display
	*oled_cm = 0xAE; //display off
 472:	e0 91 08 01 	lds	r30, 0x0108
 476:	f0 91 09 01 	lds	r31, 0x0109
 47a:	8e ea       	ldi	r24, 0xAE	; 174
 47c:	80 83       	st	Z, r24
	*oled_cm = 0xA1; //segment remap
 47e:	e0 91 08 01 	lds	r30, 0x0108
 482:	f0 91 09 01 	lds	r31, 0x0109
 486:	81 ea       	ldi	r24, 0xA1	; 161
 488:	80 83       	st	Z, r24
	*oled_cm = 0xDA; //common pads hardware: alternative
 48a:	e0 91 08 01 	lds	r30, 0x0108
 48e:	f0 91 09 01 	lds	r31, 0x0109
 492:	8a ed       	ldi	r24, 0xDA	; 218
 494:	80 83       	st	Z, r24
	*oled_cm = 0x12;
 496:	e0 91 08 01 	lds	r30, 0x0108
 49a:	f0 91 09 01 	lds	r31, 0x0109
 49e:	82 e1       	ldi	r24, 0x12	; 18
 4a0:	80 83       	st	Z, r24
	*oled_cm = 0xC8; //common output scan direction:com63~com0
 4a2:	e0 91 08 01 	lds	r30, 0x0108
 4a6:	f0 91 09 01 	lds	r31, 0x0109
 4aa:	88 ec       	ldi	r24, 0xC8	; 200
 4ac:	80 83       	st	Z, r24
	*oled_cm = 0xA8; //multiplex ration mode:63
 4ae:	e0 91 08 01 	lds	r30, 0x0108
 4b2:	f0 91 09 01 	lds	r31, 0x0109
 4b6:	88 ea       	ldi	r24, 0xA8	; 168
 4b8:	80 83       	st	Z, r24
	*oled_cm = 0x3F;
 4ba:	e0 91 08 01 	lds	r30, 0x0108
 4be:	f0 91 09 01 	lds	r31, 0x0109
 4c2:	8f e3       	ldi	r24, 0x3F	; 63
 4c4:	80 83       	st	Z, r24
	*oled_cm = 0xD5; //display divide ratio/osc. freq. mode
 4c6:	e0 91 08 01 	lds	r30, 0x0108
 4ca:	f0 91 09 01 	lds	r31, 0x0109
 4ce:	85 ed       	ldi	r24, 0xD5	; 213
 4d0:	80 83       	st	Z, r24
	*oled_cm = 0x80;
 4d2:	e0 91 08 01 	lds	r30, 0x0108
 4d6:	f0 91 09 01 	lds	r31, 0x0109
 4da:	80 e8       	ldi	r24, 0x80	; 128
 4dc:	80 83       	st	Z, r24
	*oled_cm = 0x81; //contrast control
 4de:	e0 91 08 01 	lds	r30, 0x0108
 4e2:	f0 91 09 01 	lds	r31, 0x0109
 4e6:	81 e8       	ldi	r24, 0x81	; 129
 4e8:	80 83       	st	Z, r24
	*oled_cm = 0x50;
 4ea:	e0 91 08 01 	lds	r30, 0x0108
 4ee:	f0 91 09 01 	lds	r31, 0x0109
 4f2:	80 e5       	ldi	r24, 0x50	; 80
 4f4:	80 83       	st	Z, r24
	*oled_cm = 0xD9; //set pre-charge period
 4f6:	e0 91 08 01 	lds	r30, 0x0108
 4fa:	f0 91 09 01 	lds	r31, 0x0109
 4fe:	89 ed       	ldi	r24, 0xD9	; 217
 500:	80 83       	st	Z, r24
	*oled_cm = 0x21;
 502:	e0 91 08 01 	lds	r30, 0x0108
 506:	f0 91 09 01 	lds	r31, 0x0109
 50a:	81 e2       	ldi	r24, 0x21	; 33
 50c:	80 83       	st	Z, r24
	*oled_cm = 0x20; //set Memory Addressing Mode
 50e:	e0 91 08 01 	lds	r30, 0x0108
 512:	f0 91 09 01 	lds	r31, 0x0109
 516:	80 e2       	ldi	r24, 0x20	; 32
 518:	80 83       	st	Z, r24
	*oled_cm = 0x02;
 51a:	e0 91 08 01 	lds	r30, 0x0108
 51e:	f0 91 09 01 	lds	r31, 0x0109
 522:	82 e0       	ldi	r24, 0x02	; 2
 524:	80 83       	st	Z, r24
	*oled_cm = 0xDB; //VCOM deselect level mode
 526:	e0 91 08 01 	lds	r30, 0x0108
 52a:	f0 91 09 01 	lds	r31, 0x0109
 52e:	8b ed       	ldi	r24, 0xDB	; 219
 530:	80 83       	st	Z, r24
	*oled_cm = 0x30;
 532:	e0 91 08 01 	lds	r30, 0x0108
 536:	f0 91 09 01 	lds	r31, 0x0109
 53a:	80 e3       	ldi	r24, 0x30	; 48
 53c:	80 83       	st	Z, r24
	*oled_cm = 0xAD; //master configuration
 53e:	e0 91 08 01 	lds	r30, 0x0108
 542:	f0 91 09 01 	lds	r31, 0x0109
 546:	8d ea       	ldi	r24, 0xAD	; 173
 548:	80 83       	st	Z, r24
	*oled_cm = 0x00;
 54a:	e0 91 08 01 	lds	r30, 0x0108
 54e:	f0 91 09 01 	lds	r31, 0x0109
 552:	10 82       	st	Z, r1
	*oled_cm = 0xA4; //out follows RAM content
 554:	e0 91 08 01 	lds	r30, 0x0108
 558:	f0 91 09 01 	lds	r31, 0x0109
 55c:	84 ea       	ldi	r24, 0xA4	; 164
 55e:	80 83       	st	Z, r24
	*oled_cm = 0xA6; //set normal display
 560:	e0 91 08 01 	lds	r30, 0x0108
 564:	f0 91 09 01 	lds	r31, 0x0109
 568:	86 ea       	ldi	r24, 0xA6	; 166
 56a:	80 83       	st	Z, r24
	*oled_cm = 0xAF; //display on
 56c:	e0 91 08 01 	lds	r30, 0x0108
 570:	f0 91 09 01 	lds	r31, 0x0109
 574:	8f ea       	ldi	r24, 0xAF	; 175
 576:	80 83       	st	Z, r24
	
	//Set lower column start address
	*oled_cm = 0x00;
 578:	e0 91 08 01 	lds	r30, 0x0108
 57c:	f0 91 09 01 	lds	r31, 0x0109
 580:	10 82       	st	Z, r1
	//Set higher column start address
	*oled_cm = 0x10;
 582:	e0 91 08 01 	lds	r30, 0x0108
 586:	f0 91 09 01 	lds	r31, 0x0109
 58a:	80 e1       	ldi	r24, 0x10	; 16
 58c:	80 83       	st	Z, r24
	//Set page start address
	*oled_cm = 0xB0;
 58e:	e0 91 08 01 	lds	r30, 0x0108
 592:	f0 91 09 01 	lds	r31, 0x0109
 596:	80 eb       	ldi	r24, 0xB0	; 176
 598:	80 83       	st	Z, r24
	
	//Clear the display
	for (int k = 0; k < 8; k++) {
 59a:	c0 e0       	ldi	r28, 0x00	; 0
 59c:	d0 e0       	ldi	r29, 0x00	; 0
		OLED_clear_line(k);
 59e:	ce 01       	movw	r24, r28
 5a0:	0e 94 0e 02 	call	0x41c	; 0x41c <OLED_clear_line>
	*oled_cm = 0x10;
	//Set page start address
	*oled_cm = 0xB0;
	
	//Clear the display
	for (int k = 0; k < 8; k++) {
 5a4:	21 96       	adiw	r28, 0x01	; 1
 5a6:	c8 30       	cpi	r28, 0x08	; 8
 5a8:	d1 05       	cpc	r29, r1
 5aa:	c9 f7       	brne	.-14     	; 0x59e <__stack+0x9f>
		OLED_clear_line(k);
	}

	return 0;
}
 5ac:	80 e0       	ldi	r24, 0x00	; 0
 5ae:	90 e0       	ldi	r25, 0x00	; 0
 5b0:	df 91       	pop	r29
 5b2:	cf 91       	pop	r28
 5b4:	08 95       	ret

000005b6 <OLED_pos>:
		//Set higher column start address
		//*oled_cm = (col & 0xF0) | 0x10;
	}
	
	//Set row
	if (row < 8) {
 5b6:	88 30       	cpi	r24, 0x08	; 8
 5b8:	91 05       	cpc	r25, r1
 5ba:	3c f4       	brge	.+14     	; 0x5ca <OLED_pos+0x14>
		//Set page address
		*oled_cm = 0xB0 | row;
 5bc:	e0 91 08 01 	lds	r30, 0x0108
 5c0:	f0 91 09 01 	lds	r31, 0x0109
 5c4:	80 6b       	ori	r24, 0xB0	; 176
 5c6:	9f 6f       	ori	r25, 0xFF	; 255
 5c8:	80 83       	st	Z, r24
	}
	
	return 0;
}
 5ca:	80 e0       	ldi	r24, 0x00	; 0
 5cc:	90 e0       	ldi	r25, 0x00	; 0
 5ce:	08 95       	ret

000005d0 <OLED_print_char>:

int OLED_print_char(char data) {
	uint8_t character = data - 32;
 5d0:	80 52       	subi	r24, 0x20	; 32
	
	//Write the complete character (8x8)
	for(int i = 0; i < 8; i++) {
 5d2:	20 e0       	ldi	r18, 0x00	; 0
 5d4:	30 e0       	ldi	r19, 0x00	; 0
		*oled_dt = pgm_read_byte(&font[character][i]);
 5d6:	90 e0       	ldi	r25, 0x00	; 0
 5d8:	88 0f       	add	r24, r24
 5da:	99 1f       	adc	r25, r25
 5dc:	88 0f       	add	r24, r24
 5de:	99 1f       	adc	r25, r25
 5e0:	88 0f       	add	r24, r24
 5e2:	99 1f       	adc	r25, r25
 5e4:	a0 91 06 01 	lds	r26, 0x0106
 5e8:	b0 91 07 01 	lds	r27, 0x0107
 5ec:	fc 01       	movw	r30, r24
 5ee:	e2 0f       	add	r30, r18
 5f0:	f3 1f       	adc	r31, r19
 5f2:	e0 59       	subi	r30, 0x90	; 144
 5f4:	ff 4f       	sbci	r31, 0xFF	; 255
 5f6:	e4 91       	lpm	r30, Z
 5f8:	ec 93       	st	X, r30

int OLED_print_char(char data) {
	uint8_t character = data - 32;
	
	//Write the complete character (8x8)
	for(int i = 0; i < 8; i++) {
 5fa:	2f 5f       	subi	r18, 0xFF	; 255
 5fc:	3f 4f       	sbci	r19, 0xFF	; 255
 5fe:	28 30       	cpi	r18, 0x08	; 8
 600:	31 05       	cpc	r19, r1
 602:	81 f7       	brne	.-32     	; 0x5e4 <OLED_print_char+0x14>
		*oled_dt = pgm_read_byte(&font[character][i]);
	}
	
	return 0;
}
 604:	80 e0       	ldi	r24, 0x00	; 0
 606:	90 e0       	ldi	r25, 0x00	; 0
 608:	08 95       	ret

0000060a <OLED_printf>:

int OLED_printf(char *data) {
 60a:	cf 93       	push	r28
 60c:	df 93       	push	r29
 60e:	ec 01       	movw	r28, r24
	int i = 0;
	
	//Write the string
	while (data[i] > 0x1F && data[i] < 0x7F){
 610:	88 81       	ld	r24, Y
 612:	98 2f       	mov	r25, r24
 614:	90 52       	subi	r25, 0x20	; 32
 616:	9f 35       	cpi	r25, 0x5F	; 95
 618:	40 f4       	brcc	.+16     	; 0x62a <OLED_printf+0x20>
	}
	
	return 0;
}

int OLED_printf(char *data) {
 61a:	21 96       	adiw	r28, 0x01	; 1
	int i = 0;
	
	//Write the string
	while (data[i] > 0x1F && data[i] < 0x7F){
		OLED_print_char(data[i]);
 61c:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <OLED_print_char>

int OLED_printf(char *data) {
	int i = 0;
	
	//Write the string
	while (data[i] > 0x1F && data[i] < 0x7F){
 620:	89 91       	ld	r24, Y+
 622:	98 2f       	mov	r25, r24
 624:	90 52       	subi	r25, 0x20	; 32
 626:	9f 35       	cpi	r25, 0x5F	; 95
 628:	c8 f3       	brcs	.-14     	; 0x61c <OLED_printf+0x12>
		OLED_print_char(data[i]);
		i++;
	}
	
	return 0;
 62a:	80 e0       	ldi	r24, 0x00	; 0
 62c:	90 e0       	ldi	r25, 0x00	; 0
 62e:	df 91       	pop	r29
 630:	cf 91       	pop	r28
 632:	08 95       	ret

00000634 <_exit>:
 634:	f8 94       	cli

00000636 <__stop_program>:
 636:	ff cf       	rjmp	.-2      	; 0x636 <__stop_program>
