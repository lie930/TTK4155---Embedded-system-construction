
ByggernNode1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000010  00800100  00000618  0000068c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000618  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .stab         00000cf0  00000000  00000000  0000069c  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000272  00000000  00000000  0000138c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .comment      0000002f  00000000  00000000  000015fe  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000238  00000000  00000000  0000162d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001d42  00000000  00000000  00001865  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000fdb  00000000  00000000  000035a7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000014e1  00000000  00000000  00004582  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000044c  00000000  00000000  00005a64  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000779  00000000  00000000  00005eb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000016d9  00000000  00000000  00006629  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000180  00000000  00000000  00007d02  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:

uint8_t ADC_read(uint8_t channel) {
	//Address for the ADC
	volatile char *adc = (char *) 0x1400;
	
	if(channel > 3) {return 0;}
   0:	0c 94 b4 01 	jmp	0x368	; 0x368 <__ctors_end>
	
	//Choose channel in ADC
	*adc = 0x04 | channel;
   4:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
   8:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
	
	//Wait for the data to be read
	while(test_bit(PINE, PINE0));
   c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
	
	return *adc;
  10:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>

uint8_t ADC_read(uint8_t channel) {
	//Address for the ADC
	volatile char *adc = (char *) 0x1400;
	
	if(channel > 3) {return 0;}
  14:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
	x = ADC_read(0);
	//Read position y from channel 1
	y = ADC_read(1);
	
	//Calculate position x percentage
	if(x > mid_x) {
  18:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
		position.x = 100 * (x - mid_x) / (0xFF - mid_x);
  1c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  20:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  24:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  28:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  2c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  30:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  34:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  38:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  3c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  40:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
	} else if (x < mid_x) {
  44:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
		position.x = 100 * (x - mid_x) / (mid_x - 0);
  48:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  4c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  50:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  54:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  58:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  5c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  60:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  64:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
  68:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
	} else {
		position.x = 0;
	}
	
	//Calculate position y percentage
	if(y > mid_y) {
  6c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>

00000070 <font>:
	...
		position.y = 100 * (y - mid_y) / (0xFF - mid_y);
  78:	00 06 5f 5f 06 00 00 00 00 07 07 00 07 07 00 00     ..__............
  88:	14 7f 7f 14 7f 7f 14 00 24 2e 6b 6b 3a 12 00 00     ........$.kk:...
  98:	46 66 30 18 0c 66 62 00 30 7a 4f 5d 37 7a 48 00     Ff0..fb.0zO]7zH.
	} else if (y < mid_y) {
		position.y = 100 * (y - mid_y) / (mid_y - 0);
  a8:	04 07 03 00 00 00 00 00 00 1c 3e 63 41 00 00 00     ..........>cA...
  b8:	00 41 63 3e 1c 00 00 00 08 2a 3e 1c 1c 3e 2a 08     .Ac>.....*>..>*.
	} else {
		position.y = 0;
	}
	
	return position;
}
  c8:	08 08 3e 3e 08 08 00 00 00 a0 e0 60 00 00 00 00     ..>>.......`....
			printf("SRAM error (read phase): ext_ram[%d] = %02X (should be %02X)\r\n", i, ext_ram[i], testvalue);
			rerrors++;
		}
	}

	printf("SRAM test completed with %d errors in write phase and %d errors in read phase\r\n", werrors, rerrors);
  d8:	08 08 08 08 08 08 00 00 00 00 60 60 00 00 00 00     ..........``....
  e8:	60 30 18 0c 06 03 01 00 3e 7f 59 4d 7f 3e 00 00     `0......>.YM.>..
  f8:	42 42 7f 7f 40 40 00 00 62 73 59 49 6f 66 00 00     BB..@@..bsYIof..
 108:	22 63 49 49 7f 36 00 00 18 1c 16 13 7f 7f 10 00     "cII.6..........
 118:	27 67 45 45 7d 39 00 00 3c 7e 4b 49 79 30 00 00     'gEE}9..<~KIy0..
 128:	03 63 71 19 0f 07 00 00 36 7f 49 49 7f 36 00 00     .cq.....6.II.6..
 138:	06 4f 49 69 3f 1e 00 00 00 00 6c 6c 00 00 00 00     .OIi?.....ll....
 148:	00 a0 ec 6c 00 00 00 00 08 1c 36 63 41 00 00 00     ...l......6cA...
 158:	14 14 14 14 14 14 00 00 00 41 63 36 1c 08 00 00     .........Ac6....
 168:	02 03 51 59 0f 06 00 00 3e 7f 41 5d 5d 1f 1e 00     ..QY....>.A]]...
 178:	7c 7e 13 13 7e 7c 00 00 41 7f 7f 49 49 7f 36 00     |~..~|..A..II.6.
 188:	1c 3e 63 41 41 63 22 00 41 7f 7f 41 63 7f 1c 00     .>cAAc".A..Ac...
 198:	41 7f 7f 49 5d 41 63 00 41 7f 7f 49 1d 01 03 00     A..I]Ac.A..I....
 1a8:	1c 3e 63 41 51 73 72 00 7f 7f 08 08 7f 7f 00 00     .>cAQsr.........
 1b8:	00 41 7f 7f 41 00 00 00 30 70 40 41 7f 3f 01 00     .A..A...0p@A.?..
 1c8:	41 7f 7f 08 1c 77 63 00 41 7f 7f 41 40 60 70 00     A....wc.A..A@`p.
 1d8:	7f 7f 06 0c 06 7f 7f 00 7f 7f 06 0c 18 7f 7f 00     ................
 1e8:	1c 3e 63 41 63 3e 1c 00 41 7f 7f 49 09 0f 06 00     .>cAc>..A..I....
 1f8:	1e 3f 21 71 7f 5e 00 00 41 7f 7f 19 39 6f 46 00     .?!q.^..A...9oF.
 208:	26 67 4d 59 7b 32 00 00 03 41 7f 7f 41 03 00 00     &gMY{2...A..A...
 218:	7f 7f 40 40 7f 7f 00 00 1f 3f 60 60 3f 1f 00 00     ..@@.....?``?...
 228:	7f 7f 30 18 30 7f 7f 00 63 77 1c 08 1c 77 63 00     ..0.0...cw...wc.
 238:	07 4f 78 78 4f 07 00 00 67 73 59 4d 47 63 71 00     .OxxO...gsYMGcq.
 248:	00 7f 7f 41 41 00 00 00 01 03 06 0c 18 30 60 00     ...AA........0`.
 258:	00 41 41 7f 7f 00 00 00 08 0c 06 03 06 0c 08 00     .AA.............
 268:	80 80 80 80 80 80 80 80 00 00 03 07 04 00 00 00     ................
 278:	20 74 54 54 3c 78 40 00 41 3f 7f 44 44 7c 38 00      tTT<x@.A?.DD|8.
 288:	38 7c 44 44 6c 28 00 00 30 78 48 49 3f 7f 40 00     8|DDl(..0xHI?.@.
 298:	38 7c 54 54 5c 18 00 00 48 7e 7f 49 03 02 00 00     8|TT\...H~.I....
 2a8:	98 bc a4 a4 f8 7c 04 00 41 7f 7f 08 04 7c 78 00     .....|..A....|x.
 2b8:	00 44 7d 7d 40 00 00 00 40 c4 84 fd 7d 00 00 00     .D}}@...@...}...
 2c8:	41 7f 7f 10 38 6c 44 00 00 41 7f 7f 40 00 00 00     A...8lD..A..@...
 2d8:	7c 7c 0c 18 0c 7c 78 00 7c 7c 04 04 7c 78 00 00     ||...|x.||..|x..
 2e8:	38 7c 44 44 7c 38 00 00 84 fc f8 a4 24 3c 18 00     8|DD|8......$<..
 2f8:	18 3c 24 a4 f8 fc 84 00 44 7c 78 44 1c 18 00 00     .<$.....D|xD....
 308:	48 5c 54 54 74 24 00 00 00 04 3e 7f 44 24 00 00     H\TTt$....>.D$..
 318:	3c 7c 40 40 3c 7c 40 00 1c 3c 60 60 3c 1c 00 00     <|@@<|@..<``<...
 328:	3c 7c 60 30 60 7c 3c 00 44 6c 38 10 38 6c 44 00     <|`0`|<.Dl8.8lD.
 338:	9c bc a0 a0 fc 7c 00 00 4c 64 74 5c 4c 64 00 00     .....|..Ldt\Ld..
 348:	08 08 3e 77 41 41 00 00 00 00 00 77 77 00 00 00     ..>wAA.....ww...
 358:	41 41 77 3e 08 08 00 00 02 03 01 03 02 03 01 00     AAw>............

00000368 <__ctors_end>:
 368:	11 24       	eor	r1, r1
 36a:	1f be       	out	0x3f, r1	; 63
 36c:	cf ef       	ldi	r28, 0xFF	; 255
 36e:	d4 e0       	ldi	r29, 0x04	; 4
 370:	de bf       	out	0x3e, r29	; 62
 372:	cd bf       	out	0x3d, r28	; 61

00000374 <__do_copy_data>:
 374:	11 e0       	ldi	r17, 0x01	; 1
 376:	a0 e0       	ldi	r26, 0x00	; 0
 378:	b1 e0       	ldi	r27, 0x01	; 1
 37a:	e8 e1       	ldi	r30, 0x18	; 24
 37c:	f6 e0       	ldi	r31, 0x06	; 6
 37e:	02 c0       	rjmp	.+4      	; 0x384 <__do_copy_data+0x10>
 380:	05 90       	lpm	r0, Z+
 382:	0d 92       	st	X+, r0
 384:	a0 31       	cpi	r26, 0x10	; 16
 386:	b1 07       	cpc	r27, r17
 388:	d9 f7       	brne	.-10     	; 0x380 <__do_copy_data+0xc>

0000038a <__do_clear_bss>:
 38a:	21 e0       	ldi	r18, 0x01	; 1
 38c:	a0 e1       	ldi	r26, 0x10	; 16
 38e:	b1 e0       	ldi	r27, 0x01	; 1
 390:	01 c0       	rjmp	.+2      	; 0x394 <.do_clear_bss_start>

00000392 <.do_clear_bss_loop>:
 392:	1d 92       	st	X+, r1

00000394 <.do_clear_bss_start>:
 394:	a0 31       	cpi	r26, 0x10	; 16
 396:	b2 07       	cpc	r27, r18
 398:	e1 f7       	brne	.-8      	; 0x392 <.do_clear_bss_loop>
 39a:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <main>
 39e:	0c 94 0a 03 	jmp	0x614	; 0x614 <_exit>

000003a2 <__bad_interrupt>:
 3a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000003a6 <main>:
 3a6:	0e 94 2e 02 	call	0x45c	; 0x45c <OLED_init>
 3aa:	81 e0       	ldi	r24, 0x01	; 1
 3ac:	90 e0       	ldi	r25, 0x00	; 0
 3ae:	0e 94 ef 01 	call	0x3de	; 0x3de <OLED_goto_line>
 3b2:	8a e0       	ldi	r24, 0x0A	; 10
 3b4:	91 e0       	ldi	r25, 0x01	; 1
 3b6:	0e 94 f5 02 	call	0x5ea	; 0x5ea <OLED_printf>

	/*TEST OLED*/
	OLED_init();
	OLED_goto_line(1);
	OLED_printf("hola");
	OLED_goto_line(2);
 3ba:	82 e0       	ldi	r24, 0x02	; 2
 3bc:	90 e0       	ldi	r25, 0x00	; 0
 3be:	0e 94 ef 01 	call	0x3de	; 0x3de <OLED_goto_line>
	OLED_printf("hola");
 3c2:	8a e0       	ldi	r24, 0x0A	; 10
 3c4:	91 e0       	ldi	r25, 0x01	; 1
 3c6:	0e 94 f5 02 	call	0x5ea	; 0x5ea <OLED_printf>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 3ca:	21 e3       	ldi	r18, 0x31	; 49
 3cc:	80 e0       	ldi	r24, 0x00	; 0
 3ce:	9f e0       	ldi	r25, 0x0F	; 15
 3d0:	21 50       	subi	r18, 0x01	; 1
 3d2:	80 40       	sbci	r24, 0x00	; 0
 3d4:	90 40       	sbci	r25, 0x00	; 0
 3d6:	e1 f7       	brne	.-8      	; 0x3d0 <main+0x2a>
 3d8:	00 c0       	rjmp	.+0      	; 0x3da <main+0x34>
 3da:	00 00       	nop
 3dc:	f6 cf       	rjmp	.-20     	; 0x3ca <main+0x24>

000003de <OLED_goto_line>:
	return 0;
}

int OLED_goto_line(int line) {
	//Set lower column start address
	*oled_cm = 0x00;
 3de:	e0 91 08 01 	lds	r30, 0x0108
 3e2:	f0 91 09 01 	lds	r31, 0x0109
 3e6:	10 82       	st	Z, r1
	//Set higher column start address
	*oled_cm = 0x10;
 3e8:	e0 91 08 01 	lds	r30, 0x0108
 3ec:	f0 91 09 01 	lds	r31, 0x0109
 3f0:	20 e1       	ldi	r18, 0x10	; 16
 3f2:	20 83       	st	Z, r18
	//Set page address
	if (line < 8) {
 3f4:	88 30       	cpi	r24, 0x08	; 8
 3f6:	91 05       	cpc	r25, r1
 3f8:	4c f4       	brge	.+18     	; 0x40c <OLED_goto_line+0x2e>
		*oled_cm = 0xB0 + line;	
 3fa:	e0 91 08 01 	lds	r30, 0x0108
 3fe:	f0 91 09 01 	lds	r31, 0x0109
 402:	80 55       	subi	r24, 0x50	; 80
 404:	80 83       	st	Z, r24
	} else {
		return 1;
	}
	
	return 0;
 406:	20 e0       	ldi	r18, 0x00	; 0
 408:	30 e0       	ldi	r19, 0x00	; 0
 40a:	02 c0       	rjmp	.+4      	; 0x410 <OLED_goto_line+0x32>
	*oled_cm = 0x10;
	//Set page address
	if (line < 8) {
		*oled_cm = 0xB0 + line;	
	} else {
		return 1;
 40c:	21 e0       	ldi	r18, 0x01	; 1
 40e:	30 e0       	ldi	r19, 0x00	; 0
	}
	
	return 0;
}
 410:	82 2f       	mov	r24, r18
 412:	93 2f       	mov	r25, r19
 414:	08 95       	ret

00000416 <OLED_clear_line>:

int OLED_clear_line(int line) {
	//Set page address
	int r = OLED_goto_line(line);
 416:	0e 94 ef 01 	call	0x3de	; 0x3de <OLED_goto_line>
	
	//Clear the page
	if (r == 0) {
 41a:	89 2b       	or	r24, r25
 41c:	a1 f0       	breq	.+40     	; 0x446 <OLED_clear_line+0x30>
			for(int i = 0; i < 8; i++) {
				*oled_dt = pgm_read_byte(&font[0][i]);
			}
		}
	} else {
		return 1;
 41e:	21 e0       	ldi	r18, 0x01	; 1
 420:	30 e0       	ldi	r19, 0x00	; 0
 422:	19 c0       	rjmp	.+50     	; 0x456 <OLED_clear_line+0x40>
	
	//Clear the page
	if (r == 0) {
		for (int j = 0; j < 16; j++) {
			for(int i = 0; i < 8; i++) {
				*oled_dt = pgm_read_byte(&font[0][i]);
 424:	a0 91 06 01 	lds	r26, 0x0106
 428:	b0 91 07 01 	lds	r27, 0x0107
 42c:	fc 01       	movw	r30, r24
 42e:	e0 59       	subi	r30, 0x90	; 144
 430:	ff 4f       	sbci	r31, 0xFF	; 255
 432:	e4 91       	lpm	r30, Z
 434:	ec 93       	st	X, r30
	int r = OLED_goto_line(line);
	
	//Clear the page
	if (r == 0) {
		for (int j = 0; j < 16; j++) {
			for(int i = 0; i < 8; i++) {
 436:	01 96       	adiw	r24, 0x01	; 1
 438:	88 30       	cpi	r24, 0x08	; 8
 43a:	91 05       	cpc	r25, r1
 43c:	99 f7       	brne	.-26     	; 0x424 <OLED_clear_line+0xe>
 43e:	21 50       	subi	r18, 0x01	; 1
 440:	31 09       	sbc	r19, r1
	//Set page address
	int r = OLED_goto_line(line);
	
	//Clear the page
	if (r == 0) {
		for (int j = 0; j < 16; j++) {
 442:	29 f4       	brne	.+10     	; 0x44e <OLED_clear_line+0x38>
 444:	06 c0       	rjmp	.+12     	; 0x452 <OLED_clear_line+0x3c>
int OLED_clear_line(int line) {
	//Set page address
	int r = OLED_goto_line(line);
	
	//Clear the page
	if (r == 0) {
 446:	20 e1       	ldi	r18, 0x10	; 16
 448:	30 e0       	ldi	r19, 0x00	; 0
	}
	
	return 0;
}

int OLED_clear_line(int line) {
 44a:	40 e0       	ldi	r20, 0x00	; 0
 44c:	50 e0       	ldi	r21, 0x00	; 0
 44e:	ca 01       	movw	r24, r20
 450:	e9 cf       	rjmp	.-46     	; 0x424 <OLED_clear_line+0xe>
		}
	} else {
		return 1;
	}
	
	return 0;
 452:	20 e0       	ldi	r18, 0x00	; 0
 454:	30 e0       	ldi	r19, 0x00	; 0
}
 456:	82 2f       	mov	r24, r18
 458:	93 2f       	mov	r25, r19
 45a:	08 95       	ret

0000045c <OLED_init>:
//Address for the OLED commands
volatile char *oled_cm = (char *) 0x1000;
//Address for the OLED data
volatile char *oled_dt = (char *) 0x1200;

int OLED_init(void) {
 45c:	cf 93       	push	r28
 45e:	df 93       	push	r29
	//Enable the external memory interface/4 bits address
	MCUCR  |= (1<<SRE);
 460:	85 b7       	in	r24, 0x35	; 53
 462:	80 68       	ori	r24, 0x80	; 128
 464:	85 bf       	out	0x35, r24	; 53
	SFIOR  |= (1<<XMM2);
 466:	80 b7       	in	r24, 0x30	; 48
 468:	80 62       	ori	r24, 0x20	; 32
 46a:	80 bf       	out	0x30, r24	; 48

	//Setup the OLED display
	*oled_cm = 0xAE; //display off
 46c:	e0 91 08 01 	lds	r30, 0x0108
 470:	f0 91 09 01 	lds	r31, 0x0109
 474:	8e ea       	ldi	r24, 0xAE	; 174
 476:	80 83       	st	Z, r24
	*oled_cm = 0xA1; //segment remap
 478:	e0 91 08 01 	lds	r30, 0x0108
 47c:	f0 91 09 01 	lds	r31, 0x0109
 480:	81 ea       	ldi	r24, 0xA1	; 161
 482:	80 83       	st	Z, r24
	*oled_cm = 0xDA; //common pads hardware: alternative
 484:	e0 91 08 01 	lds	r30, 0x0108
 488:	f0 91 09 01 	lds	r31, 0x0109
 48c:	8a ed       	ldi	r24, 0xDA	; 218
 48e:	80 83       	st	Z, r24
	*oled_cm = 0x12;
 490:	e0 91 08 01 	lds	r30, 0x0108
 494:	f0 91 09 01 	lds	r31, 0x0109
 498:	82 e1       	ldi	r24, 0x12	; 18
 49a:	80 83       	st	Z, r24
	*oled_cm = 0xC8; //common output scan direction:com63~com0
 49c:	e0 91 08 01 	lds	r30, 0x0108
 4a0:	f0 91 09 01 	lds	r31, 0x0109
 4a4:	88 ec       	ldi	r24, 0xC8	; 200
 4a6:	80 83       	st	Z, r24
	*oled_cm = 0xA8; //multiplex ration mode:63
 4a8:	e0 91 08 01 	lds	r30, 0x0108
 4ac:	f0 91 09 01 	lds	r31, 0x0109
 4b0:	88 ea       	ldi	r24, 0xA8	; 168
 4b2:	80 83       	st	Z, r24
	*oled_cm = 0x3F;
 4b4:	e0 91 08 01 	lds	r30, 0x0108
 4b8:	f0 91 09 01 	lds	r31, 0x0109
 4bc:	8f e3       	ldi	r24, 0x3F	; 63
 4be:	80 83       	st	Z, r24
	*oled_cm = 0xD5; //display divide ratio/osc. freq. mode
 4c0:	e0 91 08 01 	lds	r30, 0x0108
 4c4:	f0 91 09 01 	lds	r31, 0x0109
 4c8:	85 ed       	ldi	r24, 0xD5	; 213
 4ca:	80 83       	st	Z, r24
	*oled_cm = 0x80;
 4cc:	e0 91 08 01 	lds	r30, 0x0108
 4d0:	f0 91 09 01 	lds	r31, 0x0109
 4d4:	80 e8       	ldi	r24, 0x80	; 128
 4d6:	80 83       	st	Z, r24
	*oled_cm = 0x81; //contrast control
 4d8:	e0 91 08 01 	lds	r30, 0x0108
 4dc:	f0 91 09 01 	lds	r31, 0x0109
 4e0:	81 e8       	ldi	r24, 0x81	; 129
 4e2:	80 83       	st	Z, r24
	*oled_cm = 0x50;
 4e4:	e0 91 08 01 	lds	r30, 0x0108
 4e8:	f0 91 09 01 	lds	r31, 0x0109
 4ec:	80 e5       	ldi	r24, 0x50	; 80
 4ee:	80 83       	st	Z, r24
	*oled_cm = 0xD9; //set pre-charge period
 4f0:	e0 91 08 01 	lds	r30, 0x0108
 4f4:	f0 91 09 01 	lds	r31, 0x0109
 4f8:	89 ed       	ldi	r24, 0xD9	; 217
 4fa:	80 83       	st	Z, r24
	*oled_cm = 0x21;
 4fc:	e0 91 08 01 	lds	r30, 0x0108
 500:	f0 91 09 01 	lds	r31, 0x0109
 504:	81 e2       	ldi	r24, 0x21	; 33
 506:	80 83       	st	Z, r24
	*oled_cm = 0x20; //set Memory Addressing Mode
 508:	e0 91 08 01 	lds	r30, 0x0108
 50c:	f0 91 09 01 	lds	r31, 0x0109
 510:	80 e2       	ldi	r24, 0x20	; 32
 512:	80 83       	st	Z, r24
	*oled_cm = 0x02;
 514:	e0 91 08 01 	lds	r30, 0x0108
 518:	f0 91 09 01 	lds	r31, 0x0109
 51c:	82 e0       	ldi	r24, 0x02	; 2
 51e:	80 83       	st	Z, r24
	*oled_cm = 0xDB; //VCOM deselect level mode
 520:	e0 91 08 01 	lds	r30, 0x0108
 524:	f0 91 09 01 	lds	r31, 0x0109
 528:	8b ed       	ldi	r24, 0xDB	; 219
 52a:	80 83       	st	Z, r24
	*oled_cm = 0x30;
 52c:	e0 91 08 01 	lds	r30, 0x0108
 530:	f0 91 09 01 	lds	r31, 0x0109
 534:	80 e3       	ldi	r24, 0x30	; 48
 536:	80 83       	st	Z, r24
	*oled_cm = 0xAD; //master configuration
 538:	e0 91 08 01 	lds	r30, 0x0108
 53c:	f0 91 09 01 	lds	r31, 0x0109
 540:	8d ea       	ldi	r24, 0xAD	; 173
 542:	80 83       	st	Z, r24
	*oled_cm = 0x00;
 544:	e0 91 08 01 	lds	r30, 0x0108
 548:	f0 91 09 01 	lds	r31, 0x0109
 54c:	10 82       	st	Z, r1
	*oled_cm = 0xA4; //out follows RAM content
 54e:	e0 91 08 01 	lds	r30, 0x0108
 552:	f0 91 09 01 	lds	r31, 0x0109
 556:	84 ea       	ldi	r24, 0xA4	; 164
 558:	80 83       	st	Z, r24
	*oled_cm = 0xA6; //set normal display
 55a:	e0 91 08 01 	lds	r30, 0x0108
 55e:	f0 91 09 01 	lds	r31, 0x0109
 562:	86 ea       	ldi	r24, 0xA6	; 166
 564:	80 83       	st	Z, r24
	*oled_cm = 0xAF; //display on
 566:	e0 91 08 01 	lds	r30, 0x0108
 56a:	f0 91 09 01 	lds	r31, 0x0109
 56e:	8f ea       	ldi	r24, 0xAF	; 175
 570:	80 83       	st	Z, r24
	
	//Clear the display
	for (int k = 0; k < 8; k++) {
 572:	c0 e0       	ldi	r28, 0x00	; 0
 574:	d0 e0       	ldi	r29, 0x00	; 0
		OLED_clear_line(k);
 576:	ce 01       	movw	r24, r28
 578:	0e 94 0b 02 	call	0x416	; 0x416 <OLED_clear_line>
	*oled_cm = 0xA4; //out follows RAM content
	*oled_cm = 0xA6; //set normal display
	*oled_cm = 0xAF; //display on
	
	//Clear the display
	for (int k = 0; k < 8; k++) {
 57c:	21 96       	adiw	r28, 0x01	; 1
 57e:	c8 30       	cpi	r28, 0x08	; 8
 580:	d1 05       	cpc	r29, r1
 582:	c9 f7       	brne	.-14     	; 0x576 <__stack+0x77>
		OLED_clear_line(k);
	}
	
	//Set lower column start address
	*oled_cm = 0x00;
 584:	e0 91 08 01 	lds	r30, 0x0108
 588:	f0 91 09 01 	lds	r31, 0x0109
 58c:	10 82       	st	Z, r1
	//Set higher column start address
	*oled_cm = 0x10;
 58e:	e0 91 08 01 	lds	r30, 0x0108
 592:	f0 91 09 01 	lds	r31, 0x0109
 596:	80 e1       	ldi	r24, 0x10	; 16
 598:	80 83       	st	Z, r24
	//Set page start address
	*oled_cm = 0xB0;
 59a:	e0 91 08 01 	lds	r30, 0x0108
 59e:	f0 91 09 01 	lds	r31, 0x0109
 5a2:	80 eb       	ldi	r24, 0xB0	; 176
 5a4:	80 83       	st	Z, r24

	return 0;
}
 5a6:	80 e0       	ldi	r24, 0x00	; 0
 5a8:	90 e0       	ldi	r25, 0x00	; 0
 5aa:	df 91       	pop	r29
 5ac:	cf 91       	pop	r28
 5ae:	08 95       	ret

000005b0 <OLED_print_char>:
	
	return 0;
}

int OLED_print_char(char data) {
	uint8_t character = data - 32;
 5b0:	80 52       	subi	r24, 0x20	; 32
	
	//Write the complete character (8x8)
	for(int i = 0; i < 8; i++) {
 5b2:	20 e0       	ldi	r18, 0x00	; 0
 5b4:	30 e0       	ldi	r19, 0x00	; 0
		*oled_dt = pgm_read_byte(&font[character][i]);
 5b6:	90 e0       	ldi	r25, 0x00	; 0
 5b8:	88 0f       	add	r24, r24
 5ba:	99 1f       	adc	r25, r25
 5bc:	88 0f       	add	r24, r24
 5be:	99 1f       	adc	r25, r25
 5c0:	88 0f       	add	r24, r24
 5c2:	99 1f       	adc	r25, r25
 5c4:	a0 91 06 01 	lds	r26, 0x0106
 5c8:	b0 91 07 01 	lds	r27, 0x0107
 5cc:	fc 01       	movw	r30, r24
 5ce:	e2 0f       	add	r30, r18
 5d0:	f3 1f       	adc	r31, r19
 5d2:	e0 59       	subi	r30, 0x90	; 144
 5d4:	ff 4f       	sbci	r31, 0xFF	; 255
 5d6:	e4 91       	lpm	r30, Z
 5d8:	ec 93       	st	X, r30

int OLED_print_char(char data) {
	uint8_t character = data - 32;
	
	//Write the complete character (8x8)
	for(int i = 0; i < 8; i++) {
 5da:	2f 5f       	subi	r18, 0xFF	; 255
 5dc:	3f 4f       	sbci	r19, 0xFF	; 255
 5de:	28 30       	cpi	r18, 0x08	; 8
 5e0:	31 05       	cpc	r19, r1
 5e2:	81 f7       	brne	.-32     	; 0x5c4 <OLED_print_char+0x14>
		*oled_dt = pgm_read_byte(&font[character][i]);
	}
	
	return 0;
}
 5e4:	80 e0       	ldi	r24, 0x00	; 0
 5e6:	90 e0       	ldi	r25, 0x00	; 0
 5e8:	08 95       	ret

000005ea <OLED_printf>:

int OLED_printf(char *data) {
 5ea:	cf 93       	push	r28
 5ec:	df 93       	push	r29
 5ee:	ec 01       	movw	r28, r24
	int i = 0;
	
	while (data[i] > 0x1F && data[i] < 0x7F){
 5f0:	88 81       	ld	r24, Y
 5f2:	98 2f       	mov	r25, r24
 5f4:	90 52       	subi	r25, 0x20	; 32
 5f6:	9f 35       	cpi	r25, 0x5F	; 95
 5f8:	40 f4       	brcc	.+16     	; 0x60a <OLED_printf+0x20>
	}
	
	return 0;
}

int OLED_printf(char *data) {
 5fa:	21 96       	adiw	r28, 0x01	; 1
	int i = 0;
	
	while (data[i] > 0x1F && data[i] < 0x7F){
		OLED_print_char(data[i]);
 5fc:	0e 94 d8 02 	call	0x5b0	; 0x5b0 <OLED_print_char>
}

int OLED_printf(char *data) {
	int i = 0;
	
	while (data[i] > 0x1F && data[i] < 0x7F){
 600:	89 91       	ld	r24, Y+
 602:	98 2f       	mov	r25, r24
 604:	90 52       	subi	r25, 0x20	; 32
 606:	9f 35       	cpi	r25, 0x5F	; 95
 608:	c8 f3       	brcs	.-14     	; 0x5fc <OLED_printf+0x12>
		OLED_print_char(data[i]);
		i++;
	}
	
	return 0;
 60a:	80 e0       	ldi	r24, 0x00	; 0
 60c:	90 e0       	ldi	r25, 0x00	; 0
 60e:	df 91       	pop	r29
 610:	cf 91       	pop	r28
 612:	08 95       	ret

00000614 <_exit>:
 614:	f8 94       	cli

00000616 <__stop_program>:
 616:	ff cf       	rjmp	.-2      	; 0x616 <__stop_program>
